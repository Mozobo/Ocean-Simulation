#pragma kernel ComputeSkyViewLUT

static const float PI = 3.14159265;
static const uint STEPS = 32;

uint _LutWidth;
uint _LutHeight;

float _PlanetRadius;
float _AtmosphereRadius;

float _MieG;

float3 _RayleighScatteringCoefficient;
float3 _RayleighAbsorptionCoefficient;
float _RayleighScaleHeight;

float3 _MieScatteringCoefficient;
float3 _MieAbsorptionCoefficient;
float _MieScaleHeight;

float3 _OzoneScatteringCoefficient;
float3 _OzoneAbsorptionCoefficient;

float3 _SunDirection;

Texture2D<float4> _TransmittanceLUT;
SamplerState sampler_TransmittanceLUT;
Texture2D<float4> _MultiscatteringLUT;
SamplerState sampler_MultiscatteringLUT;
RWTexture2D<float4> _SkyViewLUT;

bool ComputeAtmosphereTraversalAndPlanetHit(float radius, float cosAngle, out float startDistance, out float endDistance) {
    float offset = -radius * cosAngle;
    float radius2 = radius * radius;
    float ray2Center2 = radius2 - offset * offset;
    float planetRadius2 = _PlanetRadius * _PlanetRadius;
    float atmosphereRadius2 = _AtmosphereRadius * _AtmosphereRadius;
    float topHalfLength = sqrt(atmosphereRadius2 - ray2Center2);
    startDistance = max(0.0, offset - topHalfLength);
    
    if (ray2Center2 < planetRadius2 && cosAngle < 0.0) {
        float bottomHalfLength = sqrt(planetRadius2 - ray2Center2);
        endDistance = offset - bottomHalfLength;
        return true;
    } else {
        endDistance = topHalfLength + offset; 
        return false;
    }
}

float GetMiePhase(float cosTheta) {
    float scale = 3.0 / (8.0 * PI);
    
    float num = (1.0 - _MieG * _MieG) * (1.0 + cosTheta * cosTheta);
    float denom = (2.0 + _MieG * _MieG) * pow(abs(1.0 + _MieG * _MieG - 2.0 * _MieG * cosTheta), 1.5);
    
    return scale * num / denom;
}

float GetRayleighPhase(float cosTheta) {
    float scale = 3.0 / (16.0 * PI);

    return scale * (1.0 + cosTheta * cosTheta);
}

float3 SampleTransmittanceLUT(float radius, float cosAngle) {
    float2 uv = float2(
        clamp((radius - _PlanetRadius) / (_AtmosphereRadius - _PlanetRadius), 0.0, 1.0),
        clamp(0.5 + 0.5 * cosAngle, 0.0, 1.0)
    );
    return _TransmittanceLUT.SampleLevel(sampler_TransmittanceLUT, uv, 0).rgb;
}

float3 SampleMultiscatteringLUT(float radius, float cosAngle) {
    float2 uv = float2(
        clamp((radius - _PlanetRadius) / (_AtmosphereRadius - _PlanetRadius), 0.0, 1.0),
        clamp(0.5 + 0.5 * cosAngle, 0.0, 1.0)
    );
    return _MultiscatteringLUT.SampleLevel(sampler_MultiscatteringLUT, uv, 0).rgb; 
}

[numthreads(8,8,1)]
void ComputeSkyViewLUT (uint3 id : SV_DispatchThreadID) {
    const float3 up = float3(0.0, 1.0, 0.0);

    float longitude = lerp(-PI, PI, (id.x + 0.5) / (_LutWidth - 1.0));
    float v = lerp(1.0, 0.0, (id.y + 0.5) / (_LutHeight - 1.0));

    float radius = _PlanetRadius;
    float horizon = sqrt(radius * radius - _PlanetRadius * _PlanetRadius);
	float beta = acos(horizon / radius);
	float zenithHorizonAngle = PI - beta;

    float latitude = v * 2.0 - 1.0;
    latitude *= latitude;
    if (v < 0.5) latitude = (1.0 - latitude) * zenithHorizonAngle;
    else latitude = zenithHorizonAngle + latitude * beta;
    
    float3 rayDirection = float3(sin(longitude) * sin(latitude), cos(latitude), cos(longitude) * sin(latitude));
    float3 rayOrigin = float3(0.0, radius, 0.0);
    float3 sunDirection = normalize(_SunDirection);

    float cosSunRay = dot(rayDirection, sunDirection);

    float3 rayleighPhase = _RayleighScatteringCoefficient * GetRayleighPhase(cosSunRay);
    float3 miePhase = _MieScatteringCoefficient * GetMiePhase(cosSunRay);

    float startDistance, endDistance;
    ComputeAtmosphereTraversalAndPlanetHit(radius, cos(latitude), startDistance, endDistance);
    float stepSize = (endDistance - startDistance) / float(STEPS);

    float3 transmittance = 1.0;
    float3 luminance = 0.0;
    float currentDistance = stepSize * 0.5 + startDistance;

    float3 rayleighExtinctionCoefficient = _RayleighScatteringCoefficient + _RayleighAbsorptionCoefficient;
    float3 mieExtinctionCoefficient = _MieScatteringCoefficient + _MieAbsorptionCoefficient;
    float3 ozoneExtinctionCoefficient = _OzoneScatteringCoefficient + _OzoneAbsorptionCoefficient;

    for (uint i = 0; i < STEPS; i++) {
        float3 samplePosition = rayOrigin + currentDistance * rayDirection;
        float sampleRadius = length(samplePosition);
        float sampleHeight = sampleRadius - _PlanetRadius;

        float rayleighDensity = exp(-sampleHeight/_RayleighScaleHeight);
        float mieDensity = exp(-sampleHeight/_MieScaleHeight);
        float ozoneDensity = max(0.0, 1.0 - (sampleHeight - 25000) / 15000);

        float cosSunAngle = dot(up, sunDirection);
        float3 transmittanceToSun = SampleTransmittanceLUT(sampleRadius, cosSunAngle);
        float3 inscattering = transmittanceToSun * (rayleighDensity * rayleighPhase + mieDensity * miePhase);
        float3 sampleScattering = _RayleighScatteringCoefficient * rayleighDensity + _MieScatteringCoefficient * mieDensity + _OzoneScatteringCoefficient * ozoneDensity;
        inscattering += SampleMultiscatteringLUT(sampleRadius, cosSunAngle) * sampleScattering;

        float3 sampleExtinction = rayleighExtinctionCoefficient * rayleighDensity + mieExtinctionCoefficient * mieDensity + ozoneExtinctionCoefficient * ozoneDensity;
        float3 sampleTransmittance = exp(-sampleExtinction * stepSize);
        float3 nextTransmittance = transmittance * sampleTransmittance;
        float3 transmittanceIntegral = (transmittance - nextTransmittance) / sampleExtinction;

        luminance += transmittanceIntegral * inscattering;
        currentDistance += stepSize;
        transmittance = nextTransmittance;
    }

    luminance = pow(abs(luminance), 1.0/2.2);

    _SkyViewLUT[id.xy] = float4(luminance, 1.0);
}